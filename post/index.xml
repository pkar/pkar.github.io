<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on paul karadimas</title>
    <link>https://pkar.github.io/post/</link>
    <description>Recent content in Posts on paul karadimas</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 23 Feb 2015 19:35:13 -0800</lastBuildDate>
    <atom:link href="https://pkar.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>dnsmasq on mac os x</title>
      <link>https://pkar.github.io/post/dnsmasq/</link>
      <pubDate>Mon, 23 Feb 2015 19:35:13 -0800</pubDate>
      
      <guid>https://pkar.github.io/post/dnsmasq/</guid>
      <description>

&lt;p&gt;For a simple dev environment wildcard setup&lt;/p&gt;

&lt;h2 id=&#34;install-dnsmasq:dc0fd55d5e6d99f1b0154c995452f3bf&#34;&gt;Install dnsmasq&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;brew install dnsmasq

# To have launchd start dnsmasq at startup:
# sudo cp -fv /usr/local/opt/dnsmasq/*.plist /Library/LaunchDaemons
# sudo chown root /Library/LaunchDaemons/homebrew.mxcl.dnsmasq.plist
#
# To load now
# sudo launchctl load /Library/LaunchDaemons/homebrew.mxcl.dnsmasq.plist
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;configure-dnsmasq:dc0fd55d5e6d99f1b0154c995452f3bf&#34;&gt;Configure dnsmasq&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p /usr/local/etc
echo &amp;quot;address=/local.dev.com/127.0.0.1&amp;quot; &amp;gt; /usr/local/etc/dnsmasq.conf

sudo launchctl stop homebrew.mxcl.dnsmasq
sudo launchctl start homebrew.mxcl.dnsmasq

dig boo.local.dev.com @127.0.0.1

# ; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.8.3-P1 &amp;lt;&amp;lt;&amp;gt;&amp;gt; boo.local.dev.com @127.0.0.1
# ;; global options: +cmd
# ;; Got answer:
# ;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 11853
# ;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0
#
# ;; QUESTION SECTION:
# ;boo.local.dev.com.	IN	A
#
# ;; ANSWER SECTION:
# boo.local.dev.com. 0	IN	A	127.0.0.1
#
# ;; Query time: 0 msec
# ;; SERVER: 127.0.0.1#53(127.0.0.1)
# ;; WHEN: Mon Feb 23 18:31:34 2015
# ;; MSG SIZE  rcvd: 57
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;configure-os-x:dc0fd55d5e6d99f1b0154c995452f3bf&#34;&gt;Configure OS X&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;sudo mkdir -p /etc/resolver
sudo tee /etc/resolver/local.dev.com &amp;gt;/dev/null &amp;lt;&amp;lt;EOF
nameserver 127.0.0.1
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;test-it-out:dc0fd55d5e6d99f1b0154c995452f3bf&#34;&gt;Test it out&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ping -c 1 www.google.com
PING www.google.com (216.58.216.164): 56 data bytes
64 bytes from 216.58.216.164: icmp_seq=0 ttl=55 time=16.349 ms

--- www.google.com ping statistics ---
1 packets transmitted, 1 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 16.349/16.349/16.349/0.000 ms

ping -c 1 boo.local.dev.com
PING boo.local.dev.com (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=12.879 ms

--- boo.local.dev.com ping statistics ---
1 packets transmitted, 1 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 12.879/12.879/12.879/0.000 ms
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>runit</title>
      <link>https://pkar.github.io/post/runit/</link>
      <pubDate>Wed, 04 Feb 2015 05:15:58 +0000</pubDate>
      
      <guid>https://pkar.github.io/post/runit/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/pkar/runit&#34;&gt;runit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The main use case was to have something small and easy to use
inside docker containers. It could be used to continually run
tests on changes as well I guess, among other things.&lt;/p&gt;

&lt;p&gt;Initially just using a bash script could work&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;
#!/bin/bash
export PID=

killit() {
  kill $PID
  exit
}

restartit() {
  kill $PID 
  trap - SIGINT SIGTERM EXIT
  trap - SIGHUP
  runit
}

runit() {
  /path/to/myapp -options here &amp;
  /some -other -thing &amp;
  PID=$!
  trap killit SIGINT SIGTERM EXIT
  trap restartit SIGHUP
  wait
}

runit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unless you want to for instance watch for changes and restart in say development.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;
$ # long running processes with keep alive and watch
$ runit -alive -cmd=&#34;test/test.sh&#34; -watch=./
INFO 2015/02/03 20:54:59 runit.go:100: running test/test.sh
foo
foo
foo
foo
^C
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>pruxy</title>
      <link>https://pkar.github.io/post/pruxy/</link>
      <pubDate>Wed, 05 Nov 2014 00:21:23 +0000</pubDate>
      
      <guid>https://pkar.github.io/post/pruxy/</guid>
      <description>&lt;p&gt;A simple reverse proxy that is configured through etcd.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/pkar/pruxy&#34;&gt;pruxy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The main use case was to have something light in front of docker containers
on coreos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;
docker build -t pkar/pruxy .
docker run pkar/pruxy -port=6000 -dir=/prux -etcd=$LOCAL_IP:4001,$LOCAL_IP:4002,$LOCAL_IP:4003
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>docker vagrant setup on Mac OS X</title>
      <link>https://pkar.github.io/post/dockervagrant/</link>
      <pubDate>Wed, 06 Aug 2014 20:08:03 +0000</pubDate>
      
      <guid>https://pkar.github.io/post/dockervagrant/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;
The below is outdated, with docker 1.3 you can just get the official installer.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running docker on Mac OS X isn&amp;rsquo;t simple, and I&amp;rsquo;m dumb so I had to find a better way
of doing things.&lt;/p&gt;

&lt;p&gt;The old way I did things was to use packer to build a vagrant box with docker installed.
&lt;a href=&#34;https://github.com/pkar/quasi&#34;&gt;quasi&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The reason for doing this was to be able to mount a host directory. Things have changed
with boot2docker, so the easier way I found was something like the below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;
# install some requirements, might need boot2docker HEAD if there are issues
# homebrew
ruby -e &#34;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&#34;
brew tap phinze/cask
brew install brew-cask
brew cask install virtualbox
brew cask install vagrant

brew tap homebrew/binary
brew install docker
brew install --HEAD boot2docker
boot2docker delete
boot2docker init
boot2docker stop

# download a boot2docker iso with virtualbox additions.
wget http://static.dockerfiles.io/boot2docker-v1.2.0-virtualbox-guest-additions-v4.3.14.iso
mkdir -p ~/.boot2docker
mv boot2docker-v1.2.0-virtualbox-guest-additions-v4.3.14.iso ~/.boot2docker/boot2docker.iso

# virtual box add the shared folder.
VBoxManage sharedfolder add boot2docker-vm -name home -hostpath /Users

# run boot2docker
boot2docker up

# you can manually ssh with user: docker pass: tcuser
# ssh docker@192.168.59.103
# or with boot2docker ssh

# test
boot2docker ssh &#34;ls /Users&#34;
# you should see the home directory listed here

boot2docker ip
IP=`boot2docker ip`
export DOCKER_HOST=tcp://$IP:2375

# or for instance redis in foreground
docker run --rm -i -t -p 6379:6379 dockerfile/redis
# background
docker run -d -p 6379:6379 dockerfile/redis

$ docker ps
CONTAINER ID        IMAGE                     COMMAND                CREATED              STATUS              PORTS                    NAMES
768bdf26d40a        dockerfile/redis:latest   redis-server /etc/re   About a minute ago   Up About a minute   0.0.0.0:6379-&gt;6379/tcp   goofy_pike

# in another terminal
redis-cli -h $IP

docker stop 768bdf26d40a

# run docker with whatever directory you want mounted.
docker run -i -t -v /Users/$HOME/project1:/data ubuntu /bin/bash

docker run -it --rm dockerfile/python
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://medium.com/boot2docker-lightweight-linux-for-docker/boot2docker-together-with-virtualbox-guest-additions-da1e3ab2465c&#34;&gt;reference&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>self updating go package</title>
      <link>https://pkar.github.io/post/refurbished/</link>
      <pubDate>Sun, 03 Aug 2014 00:44:38 +0000</pubDate>
      
      <guid>https://pkar.github.io/post/refurbished/</guid>
      <description>&lt;p&gt;For whatever reason I thought it&amp;rsquo;d be great to have a go binary update itself. My usual
method is to just use a &lt;a href=&#34;https://github.com/pkar/go-fabric&#34;&gt;fabric file&lt;/a&gt;. But that
got boring so I made a refurbishing package instead. &lt;a href=&#34;https://github.com/pkar/refurbish&#34;&gt;refurbish&lt;/a&gt;
&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;
package main&lt;/p&gt;

&lt;p&gt;import &amp;ldquo;github.com/pkar/refurbish&amp;rdquo;&lt;/p&gt;

&lt;p&gt;func main() {
    // Path to latest binary,
    // path to latest md5 file,
    // restart commands semicolon separated
    r := refurbish.New(
        &amp;ldquo;&lt;a href=&#34;http://example.com/path/to/binary&amp;quot;&#34;&gt;http://example.com/path/to/binary&amp;quot;&lt;/a&gt;,
        &amp;ldquo;&lt;a href=&#34;http://example.com/path/to/md5&amp;quot;&#34;&gt;http://example.com/path/to/md5&amp;quot;&lt;/a&gt;,
        &amp;ldquo;sudo initctl restart binary&amp;rdquo;,
    )
    go r.run()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Usage is pretty simple, features are for now as basic as it gets. Basically it just pings a url to check if
the binary has changed, and if so it replaces itself and reloads. Work in progress&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>stack</title>
      <link>https://pkar.github.io/post/stack/</link>
      <pubDate>Sat, 02 Aug 2014 00:48:45 +0000</pubDate>
      
      <guid>https://pkar.github.io/post/stack/</guid>
      <description>&lt;p&gt;I needed something simple to try out the formatting of this page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;
package main

import &#34;stack&#34;

func main() {
    s := stack.New()
    s.Push(1)
    s.Push(2)
    s.Push(&#34;x&#34;)

    fmt.Println(s.Len())
    // Output: 3

    x := s.Pop()
    fmt.Println(x)
    // Output: x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A human might create their directory and file layout as such
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;
$ mkdir -p src/stack
$ touch main.go # put the contents of main above
$ # copy the stack src from below to src/stack/stack.go
$ export GOPATH=$(pwd)
$ go run main.go
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the implementation of it.
&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;
// Package stack implements a basic stack data structure.
package stack&lt;/p&gt;

&lt;p&gt;// Stack holds a reference to the top of the stack
// and the current size.
type Stack struct {
    top  *Item
    size int
}&lt;/p&gt;

&lt;p&gt;// Item holds the value for the item and
// the next Item.
type Item struct {
    value interface{}
    next  *Item
}&lt;/p&gt;

&lt;p&gt;// Len returns the stacks length.
func (s *Stack) Len() int {
    return s.size
}&lt;/p&gt;

&lt;p&gt;// Push adds a new element onto the stack and
// sets top to the pushed item.
func (s *Stack) Push(value interface{}) {
    s.top = &amp;amp;Item{value: value, next: s.top}
    s.size++
}&lt;/p&gt;

&lt;p&gt;// Pop removes the top element from the stack and returns the value
// along with setting top to the next element.
// If the stack is empty, return nil
func (s *Stack) Pop() interface{} {
    if s.size &amp;gt; 0 {
        value := s.top.value
        s.top = s.top.next
        s.size&amp;ndash;
        return value
    }
    return nil
}&lt;/p&gt;

&lt;p&gt;// New is a helper for an initial stack.
func New() *Stack {
    return &amp;amp;Stack{}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>