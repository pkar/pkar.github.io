<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on paul karadimas</title>
    <link>https://pkar.github.io/tags/go/</link>
    <description>Recent content in Go on paul karadimas</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 13 Feb 2016 08:18:58 -0800</lastBuildDate>
    <atom:link href="https://pkar.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>log</title>
      <link>https://pkar.github.io/post/log/</link>
      <pubDate>Sat, 13 Feb 2016 08:18:58 -0800</pubDate>
      
      <guid>https://pkar.github.io/post/log/</guid>
      <description>&lt;p&gt;logging lib usage&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;
package main

import (
    &#34;io&#34;
    &#34;os&#34;

    &#34;github.com/pkar/log&#34;
)

func main() {
    logFile, err := os.OpenFile(&#34;log.log&#34;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
    if err != nil {
        log.Error.Fatalln(&#34;Failed to open log file&#34;, err)
    }
    log.SetFlags(log.Lshortfile)

    // default outputs
    log.Debug.Println(&#34;default debug&#34;)
    log.Info.Println(&#34;default info&#34;)
    log.Error.Printf(&#34;%s&#34;, &#34;default error&#34;)

    // Create a default output setter optionally. The initial one uses
    // ioutil.Discard, os.Stdout, os.Stderr
    var newOuts = func() {
        log.Debug.SetOutput(os.Stdout)
        log.Info.SetOutput(io.MultiWriter(os.Stdout, logFile))
        log.Error.SetOutput(os.Stderr)
    }
    log.SetOutputs(newOuts)
    // Set the level dynamically
    log.SetLevel(log.ErrorLevel)
    log.Debug.Println(&#34;debug nope&#34;)
    log.Info.Println(&#34;info nope&#34;)
    log.Error.Println(&#34;error yes&#34;)

    // Reset to debug and change flags
    log.SetFlags(log.Llongfile)
    log.SetLevel(log.DebugLevel)
    log.Debug.Println(&#34;debug yes&#34;)
    log.Info.Println(&#34;info yes&#34;)
    log.Error.Fatal(&#34;fatal&#34;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;
$ go run example/main.go
INFO: 2016/02/13 08:24:00 main.go:18: default info
ERRO: 2016/02/13 08:24:00 main.go:19: default error
ERRO: main.go:34: error yes
DEBU: /Volumes/Data/dropbox/development/euler/src/github.com/pkar/log/example/main.go:39: debug yes
INFO: /Volumes/Data/dropbox/development/euler/src/github.com/pkar/log/example/main.go:40: info yes
ERRO: /Volumes/Data/dropbox/development/euler/src/github.com/pkar/log/example/main.go:41: fatal
exit status 1
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>self updating go package</title>
      <link>https://pkar.github.io/post/refurbished/</link>
      <pubDate>Sun, 03 Aug 2014 00:44:38 +0000</pubDate>
      
      <guid>https://pkar.github.io/post/refurbished/</guid>
      <description>&lt;p&gt;For whatever reason I thought it&amp;rsquo;d be great to have a go binary update itself. My usual
method is to just use a &lt;a href=&#34;https://github.com/pkar/go-fabric&#34;&gt;fabric file&lt;/a&gt;. But that
got boring so I made a refurbishing package instead. &lt;a href=&#34;https://github.com/pkar/refurbish&#34;&gt;refurbish&lt;/a&gt;
&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;
package main&lt;/p&gt;

&lt;p&gt;import &amp;ldquo;github.com/pkar/refurbish&amp;rdquo;&lt;/p&gt;

&lt;p&gt;func main() {
    // Path to latest binary,
    // path to latest md5 file,
    // restart commands semicolon separated
    r := refurbish.New(
        &amp;ldquo;&lt;a href=&#34;http://example.com/path/to/binary&amp;quot;&#34;&gt;http://example.com/path/to/binary&amp;quot;&lt;/a&gt;,
        &amp;ldquo;&lt;a href=&#34;http://example.com/path/to/md5&amp;quot;&#34;&gt;http://example.com/path/to/md5&amp;quot;&lt;/a&gt;,
        &amp;ldquo;sudo initctl restart binary&amp;rdquo;,
    )
    go r.run()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Usage is pretty simple, features are for now as basic as it gets. Basically it just pings a url to check if
the binary has changed, and if so it replaces itself and reloads. Work in progress&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>stack</title>
      <link>https://pkar.github.io/post/stack/</link>
      <pubDate>Sat, 02 Aug 2014 00:48:45 +0000</pubDate>
      
      <guid>https://pkar.github.io/post/stack/</guid>
      <description>&lt;p&gt;I needed something simple to try out the formatting of this page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;
package main

import &#34;stack&#34;

func main() {
    s := stack.New()
    s.Push(1)
    s.Push(2)
    s.Push(&#34;x&#34;)

    fmt.Println(s.Len())
    // Output: 3

    x := s.Pop()
    fmt.Println(x)
    // Output: x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A human might create their directory and file layout as such
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;
$ mkdir -p src/stack
$ touch main.go # put the contents of main above
$ # copy the stack src from below to src/stack/stack.go
$ export GOPATH=$(pwd)
$ go run main.go
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the implementation of it.
&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;
// Package stack implements a basic stack data structure.
package stack&lt;/p&gt;

&lt;p&gt;// Stack holds a reference to the top of the stack
// and the current size.
type Stack struct {
    top  *Item
    size int
}&lt;/p&gt;

&lt;p&gt;// Item holds the value for the item and
// the next Item.
type Item struct {
    value interface{}
    next  *Item
}&lt;/p&gt;

&lt;p&gt;// Len returns the stacks length.
func (s *Stack) Len() int {
    return s.size
}&lt;/p&gt;

&lt;p&gt;// Push adds a new element onto the stack and
// sets top to the pushed item.
func (s *Stack) Push(value interface{}) {
    s.top = &amp;amp;Item{value: value, next: s.top}
    s.size++
}&lt;/p&gt;

&lt;p&gt;// Pop removes the top element from the stack and returns the value
// along with setting top to the next element.
// If the stack is empty, return nil
func (s *Stack) Pop() interface{} {
    if s.size &amp;gt; 0 {
        value := s.top.value
        s.top = s.top.next
        s.size&amp;ndash;
        return value
    }
    return nil
}&lt;/p&gt;

&lt;p&gt;// New is a helper for an initial stack.
func New() *Stack {
    return &amp;amp;Stack{}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>