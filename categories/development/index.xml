<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Development on paul karadimas</title>
    <link>https://pkar.github.io/categories/development/</link>
    <description>Recent content in Development on paul karadimas</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 13 Feb 2016 08:18:58 -0800</lastBuildDate>
    <atom:link href="https://pkar.github.io/categories/development/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>log</title>
      <link>https://pkar.github.io/post/log/</link>
      <pubDate>Sat, 13 Feb 2016 08:18:58 -0800</pubDate>
      
      <guid>https://pkar.github.io/post/log/</guid>
      <description>&lt;p&gt;logging lib usage&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;
package main

import (
    &#34;io&#34;
    &#34;os&#34;

    &#34;github.com/pkar/log&#34;
)

func main() {
    logFile, err := os.OpenFile(&#34;log.log&#34;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
    if err != nil {
        log.Error.Fatalln(&#34;Failed to open log file&#34;, err)
    }
    log.SetFlags(log.Lshortfile)

    // default outputs
    log.Debug.Println(&#34;default debug&#34;)
    log.Info.Println(&#34;default info&#34;)
    log.Error.Printf(&#34;%s&#34;, &#34;default error&#34;)

    // Create a default output setter optionally. The initial one uses
    // ioutil.Discard, os.Stdout, os.Stderr
    var newOuts = func() {
        log.Debug.SetOutput(os.Stdout)
        log.Info.SetOutput(io.MultiWriter(os.Stdout, logFile))
        log.Error.SetOutput(os.Stderr)
    }
    log.SetOutputs(newOuts)
    // Set the level dynamically
    log.SetLevel(log.ErrorLevel)
    log.Debug.Println(&#34;debug nope&#34;)
    log.Info.Println(&#34;info nope&#34;)
    log.Error.Println(&#34;error yes&#34;)

    // Reset to debug and change flags
    log.SetFlags(log.Llongfile)
    log.SetLevel(log.DebugLevel)
    log.Debug.Println(&#34;debug yes&#34;)
    log.Info.Println(&#34;info yes&#34;)
    log.Error.Fatal(&#34;fatal&#34;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;
$ go run example/main.go
INFO: 2016/02/13 08:24:00 main.go:18: default info
ERRO: 2016/02/13 08:24:00 main.go:19: default error
ERRO: main.go:34: error yes
DEBU: /Volumes/Data/dropbox/development/euler/src/github.com/pkar/log/example/main.go:39: debug yes
INFO: /Volumes/Data/dropbox/development/euler/src/github.com/pkar/log/example/main.go:40: info yes
ERRO: /Volumes/Data/dropbox/development/euler/src/github.com/pkar/log/example/main.go:41: fatal
exit status 1
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>docker vagrant setup on Mac OS X</title>
      <link>https://pkar.github.io/post/dockervagrant/</link>
      <pubDate>Wed, 06 Aug 2014 20:08:03 +0000</pubDate>
      
      <guid>https://pkar.github.io/post/dockervagrant/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;
The below is outdated, with docker 1.3 you can just get the official installer.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running docker on Mac OS X isn&amp;rsquo;t simple, and I&amp;rsquo;m dumb so I had to find a better way
of doing things.&lt;/p&gt;

&lt;p&gt;The old way I did things was to use packer to build a vagrant box with docker installed.
&lt;a href=&#34;https://github.com/pkar/quasi&#34;&gt;quasi&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The reason for doing this was to be able to mount a host directory. Things have changed
with boot2docker, so the easier way I found was something like the below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;
# install some requirements, might need boot2docker HEAD if there are issues
# homebrew
ruby -e &#34;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&#34;
brew tap phinze/cask
brew install brew-cask
brew cask install virtualbox
brew cask install vagrant

brew tap homebrew/binary
brew install docker
brew install --HEAD boot2docker
boot2docker delete
boot2docker init
boot2docker stop

# download a boot2docker iso with virtualbox additions.
wget http://static.dockerfiles.io/boot2docker-v1.2.0-virtualbox-guest-additions-v4.3.14.iso
mkdir -p ~/.boot2docker
mv boot2docker-v1.2.0-virtualbox-guest-additions-v4.3.14.iso ~/.boot2docker/boot2docker.iso

# virtual box add the shared folder.
VBoxManage sharedfolder add boot2docker-vm -name home -hostpath /Users

# run boot2docker
boot2docker up

# you can manually ssh with user: docker pass: tcuser
# ssh docker@192.168.59.103
# or with boot2docker ssh

# test
boot2docker ssh &#34;ls /Users&#34;
# you should see the home directory listed here

boot2docker ip
IP=`boot2docker ip`
export DOCKER_HOST=tcp://$IP:2375

# or for instance redis in foreground
docker run --rm -i -t -p 6379:6379 dockerfile/redis
# background
docker run -d -p 6379:6379 dockerfile/redis

$ docker ps
CONTAINER ID        IMAGE                     COMMAND                CREATED              STATUS              PORTS                    NAMES
768bdf26d40a        dockerfile/redis:latest   redis-server /etc/re   About a minute ago   Up About a minute   0.0.0.0:6379-&gt;6379/tcp   goofy_pike

# in another terminal
redis-cli -h $IP

docker stop 768bdf26d40a

# run docker with whatever directory you want mounted.
docker run -i -t -v /Users/$HOME/project1:/data ubuntu /bin/bash

docker run -it --rm dockerfile/python
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://medium.com/boot2docker-lightweight-linux-for-docker/boot2docker-together-with-virtualbox-guest-additions-da1e3ab2465c&#34;&gt;reference&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>self updating go package</title>
      <link>https://pkar.github.io/post/refurbished/</link>
      <pubDate>Sun, 03 Aug 2014 00:44:38 +0000</pubDate>
      
      <guid>https://pkar.github.io/post/refurbished/</guid>
      <description>&lt;p&gt;For whatever reason I thought it&amp;rsquo;d be great to have a go binary update itself. My usual
method is to just use a &lt;a href=&#34;https://github.com/pkar/go-fabric&#34;&gt;fabric file&lt;/a&gt;. But that
got boring so I made a refurbishing package instead. &lt;a href=&#34;https://github.com/pkar/refurbish&#34;&gt;refurbish&lt;/a&gt;
&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;
package main&lt;/p&gt;

&lt;p&gt;import &amp;ldquo;github.com/pkar/refurbish&amp;rdquo;&lt;/p&gt;

&lt;p&gt;func main() {
    // Path to latest binary,
    // path to latest md5 file,
    // restart commands semicolon separated
    r := refurbish.New(
        &amp;ldquo;&lt;a href=&#34;http://example.com/path/to/binary&amp;quot;&#34;&gt;http://example.com/path/to/binary&amp;quot;&lt;/a&gt;,
        &amp;ldquo;&lt;a href=&#34;http://example.com/path/to/md5&amp;quot;&#34;&gt;http://example.com/path/to/md5&amp;quot;&lt;/a&gt;,
        &amp;ldquo;sudo initctl restart binary&amp;rdquo;,
    )
    go r.run()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Usage is pretty simple, features are for now as basic as it gets. Basically it just pings a url to check if
the binary has changed, and if so it replaces itself and reloads. Work in progress&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>